// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: okhttp3.OkHttpClient$Builder
class OkHttpClient_Builder extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Builder> $type = type;

  OkHttpClient_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder() {
    return OkHttpClient_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_callTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"callTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder callTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_callTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_callTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"callTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder callTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_callTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_connectTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder connectTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_connectTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder connectTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_readTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder readTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_readTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder readTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_writeTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder writeTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_writeTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder writeTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_pingInterval = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"pingInterval",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder pingInterval(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pingInterval,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_pingInterval1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"pingInterval",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder pingInterval(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pingInterval1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_proxy = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"proxy", r"(Ljava/net/Proxy;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder proxy(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxy(
    jni.JObject proxy,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxy, jni.JniCallType.objectType,
            [proxy.reference]).object);
  }

  static final _id_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"proxySelector",
      r"(Ljava/net/ProxySelector;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder proxySelector(java.net.ProxySelector proxySelector)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxySelector(
    jni.JObject proxySelector,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxySelector,
            jni.JniCallType.objectType, [proxySelector.reference]).object);
  }

  static final _id_cookieJar = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"cookieJar", r"(Lokhttp3/CookieJar;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder cookieJar(okhttp3.CookieJar cookieJar)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cookieJar(
    jni.JObject cookieJar,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cookieJar,
            jni.JniCallType.objectType, [cookieJar.reference]).object);
  }

  static final _id_cache = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"cache", r"(Lokhttp3/Cache;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder cache(okhttp3.Cache cache)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cache(
    jni.JObject cache,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cache, jni.JniCallType.objectType,
            [cache.reference]).object);
  }

  static final _id_dns = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"dns", r"(Lokhttp3/Dns;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder dns(okhttp3.Dns dns)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dns(
    jni.JObject dns,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_dns, jni.JniCallType.objectType,
            [dns.reference]).object);
  }

  static final _id_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"socketFactory",
      r"(Ljavax/net/SocketFactory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder socketFactory(javax.net.SocketFactory socketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder socketFactory(
    jni.JObject socketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_socketFactory,
            jni.JniCallType.objectType, [socketFactory.reference]).object);
  }

  static final _id_sslSocketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"(Ljavax/net/ssl/SSLSocketFactory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory(
    jni.JObject sSLSocketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sslSocketFactory,
            jni.JniCallType.objectType, [sSLSocketFactory.reference]).object);
  }

  static final _id_sslSocketFactory1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"(Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory, javax.net.ssl.X509TrustManager x509TrustManager)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory1(
    jni.JObject sSLSocketFactory,
    jni.JObject x509TrustManager,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_sslSocketFactory1,
            jni.JniCallType.objectType,
            [sSLSocketFactory.reference, x509TrustManager.reference]).object);
  }

  static final _id_hostnameVerifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hostnameVerifier",
      r"(Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder hostnameVerifier(javax.net.ssl.HostnameVerifier hostnameVerifier)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder hostnameVerifier(
    jni.JObject hostnameVerifier,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_hostnameVerifier,
            jni.JniCallType.objectType, [hostnameVerifier.reference]).object);
  }

  static final _id_certificatePinner = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"certificatePinner",
      r"(Lokhttp3/CertificatePinner;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder certificatePinner(okhttp3.CertificatePinner certificatePinner)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder certificatePinner(
    jni.JObject certificatePinner,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_certificatePinner,
            jni.JniCallType.objectType, [certificatePinner.reference]).object);
  }

  static final _id_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"authenticator",
      r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder authenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder authenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_authenticator,
            jni.JniCallType.objectType, [authenticator.reference]).object);
  }

  static final _id_proxyAuthenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"proxyAuthenticator",
      r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder proxyAuthenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxyAuthenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxyAuthenticator,
            jni.JniCallType.objectType, [authenticator.reference]).object);
  }

  static final _id_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectionPool",
      r"(Lokhttp3/ConnectionPool;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder connectionPool(okhttp3.ConnectionPool connectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionPool(
    jni.JObject connectionPool,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionPool,
            jni.JniCallType.objectType, [connectionPool.reference]).object);
  }

  static final _id_followSslRedirects = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"followSslRedirects",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder followSslRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followSslRedirects(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_followSslRedirects,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);
  }

  static final _id_followRedirects = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"followRedirects",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder followRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followRedirects(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_followRedirects,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);
  }

  static final _id_retryOnConnectionFailure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"retryOnConnectionFailure",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder retryOnConnectionFailure(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder retryOnConnectionFailure(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_retryOnConnectionFailure,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);
  }

  static final _id_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatcher",
      r"(Lokhttp3/Dispatcher;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder dispatcher(okhttp3.Dispatcher dispatcher)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dispatcher(
    jni.JObject dispatcher,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_dispatcher,
            jni.JniCallType.objectType, [dispatcher.reference]).object);
  }

  static final _id_protocols = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"protocols", r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder protocols(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder protocols(
    jni.JList<jni.JObject> list,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_protocols,
            jni.JniCallType.objectType, [list.reference]).object);
  }

  static final _id_connectionSpecs = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectionSpecs",
      r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder connectionSpecs(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionSpecs(
    jni.JList<jni.JObject> list,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionSpecs,
            jni.JniCallType.objectType, [list.reference]).object);
  }

  static final _id_interceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"interceptors", r"()Ljava/util/List;");

  /// from: public java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_addInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addInterceptor",
      r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder addInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addInterceptor,
            jni.JniCallType.objectType, [interceptor.reference]).object);
  }

  static final _id_networkInterceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkInterceptors", r"()Ljava/util/List;");

  /// from: public java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_addNetworkInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addNetworkInterceptor",
      r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder addNetworkInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addNetworkInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addNetworkInterceptor,
            jni.JniCallType.objectType, [interceptor.reference]).object);
  }

  static final _id_eventListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListener",
      r"(Lokhttp3/EventListener;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder eventListener(okhttp3.EventListener eventListener)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListener(
    jni.JObject eventListener,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_eventListener,
            jni.JniCallType.objectType, [eventListener.reference]).object);
  }

  static final _id_eventListenerFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListenerFactory",
      r"(Lokhttp3/EventListener$Factory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder eventListenerFactory(okhttp3.EventListener$Factory factory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListenerFactory(
    jni.JObject factory0,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_eventListenerFactory,
            jni.JniCallType.objectType, [factory0.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/OkHttpClient;");

  /// from: public okhttp3.OkHttpClient build()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient build() {
    return const $OkHttpClientType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $OkHttpClient_BuilderType
    extends jni.JObjType<OkHttpClient_Builder> {
  const $OkHttpClient_BuilderType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Builder;";

  @override
  OkHttpClient_Builder fromRef(jni.JObjectPtr ref) =>
      OkHttpClient_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_BuilderType) &&
        other is $OkHttpClient_BuilderType;
  }
}

/// from: okhttp3.OkHttpClient
class OkHttpClient extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient> $type = type;

  OkHttpClient.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClientType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient() {
    return OkHttpClient.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_callTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"callTimeoutMillis", r"()I");

  /// from: public int callTimeoutMillis()
  int callTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_callTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_connectTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"connectTimeoutMillis", r"()I");

  /// from: public int connectTimeoutMillis()
  int connectTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_connectTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_readTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readTimeoutMillis", r"()I");

  /// from: public int readTimeoutMillis()
  int readTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_writeTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeTimeoutMillis", r"()I");

  /// from: public int writeTimeoutMillis()
  int writeTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_pingIntervalMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"pingIntervalMillis", r"()I");

  /// from: public int pingIntervalMillis()
  int pingIntervalMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_pingIntervalMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_proxy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"proxy", r"()Ljava/net/Proxy;");

  /// from: public java.net.Proxy proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxy() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_proxy, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"proxySelector", r"()Ljava/net/ProxySelector;");

  /// from: public java.net.ProxySelector proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxySelector() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_proxySelector, jni.JniCallType.objectType, []).object);
  }

  static final _id_cookieJar = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cookieJar", r"()Lokhttp3/CookieJar;");

  /// from: public okhttp3.CookieJar cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cookieJar() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cookieJar, jni.JniCallType.objectType, []).object);
  }

  static final _id_cache = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cache", r"()Lokhttp3/Cache;");

  /// from: public okhttp3.Cache cache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cache() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cache, jni.JniCallType.objectType, []).object);
  }

  static final _id_dns = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dns", r"()Lokhttp3/Dns;");

  /// from: public okhttp3.Dns dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dns() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dns, jni.JniCallType.objectType, []).object);
  }

  static final _id_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"socketFactory", r"()Ljavax/net/SocketFactory;");

  /// from: public javax.net.SocketFactory socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject socketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_socketFactory, jni.JniCallType.objectType, []).object);
  }

  static final _id_sslSocketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"()Ljavax/net/ssl/SSLSocketFactory;");

  /// from: public javax.net.ssl.SSLSocketFactory sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject sslSocketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sslSocketFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_hostnameVerifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hostnameVerifier",
      r"()Ljavax/net/ssl/HostnameVerifier;");

  /// from: public javax.net.ssl.HostnameVerifier hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject hostnameVerifier() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hostnameVerifier,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_certificatePinner = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"certificatePinner", r"()Lokhttp3/CertificatePinner;");

  /// from: public okhttp3.CertificatePinner certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificatePinner() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_certificatePinner,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"authenticator", r"()Lokhttp3/Authenticator;");

  /// from: public okhttp3.Authenticator authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject authenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_authenticator, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxyAuthenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"proxyAuthenticator", r"()Lokhttp3/Authenticator;");

  /// from: public okhttp3.Authenticator proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxyAuthenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_proxyAuthenticator,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"connectionPool", r"()Lokhttp3/ConnectionPool;");

  /// from: public okhttp3.ConnectionPool connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject connectionPool() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_connectionPool, jni.JniCallType.objectType, []).object);
  }

  static final _id_followSslRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"followSslRedirects", r"()Z");

  /// from: public boolean followSslRedirects()
  bool followSslRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_followSslRedirects, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_followRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"followRedirects", r"()Z");

  /// from: public boolean followRedirects()
  bool followRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_followRedirects,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_retryOnConnectionFailure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"retryOnConnectionFailure", r"()Z");

  /// from: public boolean retryOnConnectionFailure()
  bool retryOnConnectionFailure() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_retryOnConnectionFailure, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatcher", r"()Lokhttp3/Dispatcher;");

  /// from: public okhttp3.Dispatcher dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatcher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dispatcher, jni.JniCallType.objectType, []).object);
  }

  static final _id_protocols = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protocols", r"()Ljava/util/List;");

  /// from: public java.util.List protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> protocols() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_protocols, jni.JniCallType.objectType, []).object);
  }

  static final _id_connectionSpecs = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"connectionSpecs", r"()Ljava/util/List;");

  /// from: public java.util.List connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> connectionSpecs() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionSpecs,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_interceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"interceptors", r"()Ljava/util/List;");

  /// from: public java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_networkInterceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkInterceptors", r"()Ljava/util/List;");

  /// from: public java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_eventListenerFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListenerFactory",
      r"()Lokhttp3/EventListener$Factory;");

  /// from: public okhttp3.EventListener$Factory eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject eventListenerFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_eventListenerFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_newCall = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newCall", r"(Lokhttp3/Request;)Lokhttp3/Call;");

  /// from: public okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return const $CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newCall,
        jni.JniCallType.objectType,
        [request.reference]).object);
  }

  static final _id_newWebSocket = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"newWebSocket",
      r"(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;");

  /// from: public okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject newWebSocket(
    Request request,
    jni.JObject webSocketListener,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newWebSocket,
        jni.JniCallType.objectType,
        [request.reference, webSocketListener.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder newBuilder() {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }
}

final class $OkHttpClientType extends jni.JObjType<OkHttpClient> {
  const $OkHttpClientType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient;";

  @override
  OkHttpClient fromRef(jni.JObjectPtr ref) => OkHttpClient.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClientType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClientType) &&
        other is $OkHttpClientType;
  }
}

/// from: okhttp3.Request$Builder
class Request_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Request_Builder> $type = type;

  Request_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Request$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Request_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder() {
    return Request_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_url = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"url", r"(Lokhttp3/HttpUrl;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder url(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url(
    jni.JObject httpUrl,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url, jni.JniCallType.objectType,
            [httpUrl.reference]).object);
  }

  static final _id_url1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"url", r"(Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder url(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url1(
    jni.JString string,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url1, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_url2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"url", r"(Ljava/net/URL;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder url(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url2(
    jni.JObject uRL,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url2, jni.JniCallType.objectType,
            [uRL.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"header",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_header, jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addHeader",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_removeHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeHeader",
      r"(Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder removeHeader(
    jni.JString string,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeHeader,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"headers", r"(Lokhttp3/Headers;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder headers(
    Headers headers,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"cacheControl",
      r"(Lokhttp3/CacheControl;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder cacheControl(okhttp3.CacheControl cacheControl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder cacheControl(
    jni.JObject cacheControl,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cacheControl,
            jni.JniCallType.objectType, [cacheControl.reference]).object);
  }

  static final _id_get0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder get()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder get0() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_get0, jni.JniCallType.objectType, []).object);
  }

  static final _id_head = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"head", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder head()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder head() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_head, jni.JniCallType.objectType, []).object);
  }

  static final _id_post = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"post", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder post(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder post(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_post, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_delete = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"delete", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder delete(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_delete, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_delete1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"delete", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder delete()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete1() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_delete1, jni.JniCallType.objectType, []).object);
  }

  static final _id_put = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"put", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder put(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder put(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_put, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_patch = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"patch", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder patch(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder patch(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_patch, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_method = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"method",
      r"(Ljava/lang/String;Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder method(java.lang.String string, okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder method(
    jni.JString string,
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_method, jni.JniCallType.objectType,
            [string.reference, requestBody.reference]).object);
  }

  static final _id_tag = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"tag", r"(Ljava/lang/Object;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder tag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag(
    jni.JObject object,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_tag, jni.JniCallType.objectType,
            [object.reference]).object);
  }

  static final _id_tag1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"tag",
      r"(Ljava/lang/Class;Ljava/lang/Object;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder tag(java.lang.Class class, T object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag1<$T extends jni.JObject>(
    jni.JObject class0,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_tag1, jni.JniCallType.objectType,
            [class0.reference, object.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Request;");

  /// from: public okhttp3.Request build()
  /// The returned object must be released after use, by calling the [release] method.
  Request build() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Request_BuilderType extends jni.JObjType<Request_Builder> {
  const $Request_BuilderType();

  @override
  String get signature => r"Lokhttp3/Request$Builder;";

  @override
  Request_Builder fromRef(jni.JObjectPtr ref) => Request_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Request_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_BuilderType) &&
        other is $Request_BuilderType;
  }
}

/// from: okhttp3.Request
class Request extends jni.JObject {
  @override
  late final jni.JObjType<Request> $type = type;

  Request.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Request");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestType();
  static final _id_url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"url", r"()Lokhttp3/HttpUrl;");

  /// from: public okhttp3.HttpUrl url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject url() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_url, jni.JniCallType.objectType, []).object);
  }

  static final _id_method = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"method", r"()Ljava/lang/String;");

  /// from: public java.lang.String method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString method() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_method, jni.JniCallType.objectType, []).object);
  }

  static final _id_headers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"headers", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers headers() {
    return const $HeadersType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_headers, jni.JniCallType.objectType, []).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"header", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_headers1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"headers", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers1, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_body = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"body", r"()Lokhttp3/RequestBody;");

  /// from: public okhttp3.RequestBody body()
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody body() {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_body, jni.JniCallType.objectType, []).object);
  }

  static final _id_tag = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"tag", r"()Ljava/lang/Object;");

  /// from: public java.lang.Object tag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject tag() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_tag, jni.JniCallType.objectType, []).object);
  }

  static final _id_tag1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"tag", r"(Ljava/lang/Class;)Ljava/lang/Object;");

  /// from: public T tag(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $T tag1<$T extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(reference, _id_tag1,
        jni.JniCallType.objectType, [class0.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder newBuilder() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheControl", r"()Lokhttp3/CacheControl;");

  /// from: public okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheControl, jni.JniCallType.objectType, []).object);
  }

  static final _id_isHttps =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isHttps", r"()Z");

  /// from: public boolean isHttps()
  bool isHttps() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isHttps, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $RequestType extends jni.JObjType<Request> {
  const $RequestType();

  @override
  String get signature => r"Lokhttp3/Request;";

  @override
  Request fromRef(jni.JObjectPtr ref) => Request.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestType) && other is $RequestType;
  }
}

/// from: okhttp3.Response$Builder
class Response_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Response_Builder> $type = type;

  Response_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Response$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Response_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder() {
    return Response_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_request = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"request", r"(Lokhttp3/Request;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder request(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder request(
    Request request,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_request, jni.JniCallType.objectType,
            [request.reference]).object);
  }

  static final _id_protocol = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"protocol", r"(Lokhttp3/Protocol;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder protocol(okhttp3.Protocol protocol)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder protocol(
    jni.JObject protocol,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_protocol, jni.JniCallType.objectType,
            [protocol.reference]).object);
  }

  static final _id_code = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"code", r"(I)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder code(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder code(
    int i,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_code, jni.JniCallType.objectType,
            [jni.JValueInt(i)]).object);
  }

  static final _id_message = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"message", r"(Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder message(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder message(
    jni.JString string,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_message, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_handshake = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"handshake", r"(Lokhttp3/Handshake;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder handshake(okhttp3.Handshake handshake)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder handshake(
    jni.JObject handshake,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_handshake,
            jni.JniCallType.objectType, [handshake.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"header",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_header, jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addHeader",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_removeHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeHeader",
      r"(Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder removeHeader(
    jni.JString string,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeHeader,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"headers", r"(Lokhttp3/Headers;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder headers(
    Headers headers,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_body = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"body", r"(Lokhttp3/ResponseBody;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder body(okhttp3.ResponseBody responseBody)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder body(
    ResponseBody responseBody,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_body, jni.JniCallType.objectType,
            [responseBody.reference]).object);
  }

  static final _id_networkResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"networkResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder networkResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder networkResponse(
    Response response,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkResponse,
            jni.JniCallType.objectType, [response.reference]).object);
  }

  static final _id_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"cacheResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder cacheResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder cacheResponse(
    Response response,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cacheResponse,
            jni.JniCallType.objectType, [response.reference]).object);
  }

  static final _id_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"priorResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder priorResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder priorResponse(
    Response response,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_priorResponse,
            jni.JniCallType.objectType, [response.reference]).object);
  }

  static final _id_sentRequestAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sentRequestAtMillis",
      r"(J)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder sentRequestAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder sentRequestAtMillis(
    int j,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sentRequestAtMillis,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_receivedResponseAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"receivedResponseAtMillis",
      r"(J)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder receivedResponseAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder receivedResponseAtMillis(
    int j,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_receivedResponseAtMillis,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response build()
  /// The returned object must be released after use, by calling the [release] method.
  Response build() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Response_BuilderType extends jni.JObjType<Response_Builder> {
  const $Response_BuilderType();

  @override
  String get signature => r"Lokhttp3/Response$Builder;";

  @override
  Response_Builder fromRef(jni.JObjectPtr ref) => Response_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Response_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_BuilderType) &&
        other is $Response_BuilderType;
  }
}

/// from: okhttp3.Response
class Response extends jni.JObject {
  @override
  late final jni.JObjType<Response> $type = type;

  Response.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Response");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseType();
  static final _id_request = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"request", r"()Lokhttp3/Request;");

  /// from: public okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.objectType, []).object);
  }

  static final _id_protocol = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protocol", r"()Lokhttp3/Protocol;");

  /// from: public okhttp3.Protocol protocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject protocol() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protocol, jni.JniCallType.objectType, []).object);
  }

  static final _id_code =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"code", r"()I");

  /// from: public int code()
  int code() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_code, jni.JniCallType.intType, []).integer;
  }

  static final _id_isSuccessful = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSuccessful", r"()Z");

  /// from: public boolean isSuccessful()
  bool isSuccessful() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isSuccessful, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_message = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"message", r"()Ljava/lang/String;");

  /// from: public java.lang.String message()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString message() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_message, jni.JniCallType.objectType, []).object);
  }

  static final _id_handshake = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"handshake", r"()Lokhttp3/Handshake;");

  /// from: public okhttp3.Handshake handshake()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject handshake() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_handshake, jni.JniCallType.objectType, []).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"headers", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"header", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_header1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"header", r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header1(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header1,
        jni.JniCallType.objectType,
        [string.reference, string1.reference]).object);
  }

  static final _id_headers1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"headers", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers headers1() {
    return const $HeadersType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_headers1, jni.JniCallType.objectType, []).object);
  }

  static final _id_trailers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"trailers", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers trailers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers trailers() {
    return const $HeadersType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_trailers, jni.JniCallType.objectType, []).object);
  }

  static final _id_peekBody = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"peekBody", r"(J)Lokhttp3/ResponseBody;");

  /// from: public okhttp3.ResponseBody peekBody(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody peekBody(
    int j,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_peekBody, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_body = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"body", r"()Lokhttp3/ResponseBody;");

  /// from: public okhttp3.ResponseBody body()
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody body() {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_body, jni.JniCallType.objectType, []).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder newBuilder() {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_isRedirect =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isRedirect", r"()Z");

  /// from: public boolean isRedirect()
  bool isRedirect() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRedirect, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_networkResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkResponse", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response networkResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_networkResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheResponse", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response cacheResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"priorResponse", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response priorResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_priorResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_challenges = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"challenges", r"()Ljava/util/List;");

  /// from: public java.util.List challenges()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> challenges() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_challenges, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheControl", r"()Lokhttp3/CacheControl;");

  /// from: public okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheControl, jni.JniCallType.objectType, []).object);
  }

  static final _id_sentRequestAtMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sentRequestAtMillis", r"()J");

  /// from: public long sentRequestAtMillis()
  int sentRequestAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sentRequestAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_receivedResponseAtMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"receivedResponseAtMillis", r"()J");

  /// from: public long receivedResponseAtMillis()
  int receivedResponseAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_receivedResponseAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $ResponseType extends jni.JObjType<Response> {
  const $ResponseType();

  @override
  String get signature => r"Lokhttp3/Response;";

  @override
  Response fromRef(jni.JObjectPtr ref) => Response.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseType) && other is $ResponseType;
  }
}

/// from: okhttp3.Headers$Builder
class Headers_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Headers_Builder> $type = type;

  Headers_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Headers$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Headers_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers_Builder() {
    return Headers_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_add = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"add", r"(Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder add(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add(
    jni.JString string,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_add1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"add",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder add(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add1(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add1, jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addUnsafeNonAscii = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addUnsafeNonAscii",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder addUnsafeNonAscii(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder addUnsafeNonAscii(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addUnsafeNonAscii,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addAll = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"addAll", r"(Lokhttp3/Headers;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder addAll(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder addAll(
    Headers headers,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addAll, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_add2 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"add", r"(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder add(java.lang.String string, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add2(
    jni.JString string,
    jni.JObject date,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add2, jni.JniCallType.objectType,
            [string.reference, date.reference]).object);
  }

  static final _id_add3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"add",
      r"(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder add(java.lang.String string, java.time.Instant instant)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add3(
    jni.JString string,
    jni.JObject instant,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add3, jni.JniCallType.objectType,
            [string.reference, instant.reference]).object);
  }

  static final _id_set0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"set", r"(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder set(java.lang.String string, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set0(
    jni.JString string,
    jni.JObject date,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_set0, jni.JniCallType.objectType,
            [string.reference, date.reference]).object);
  }

  static final _id_set1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"set",
      r"(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder set(java.lang.String string, java.time.Instant instant)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set1(
    jni.JString string,
    jni.JObject instant,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_set1, jni.JniCallType.objectType,
            [string.reference, instant.reference]).object);
  }

  static final _id_removeAll = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"removeAll", r"(Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder removeAll(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder removeAll(
    jni.JString string,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeAll,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_set2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"set",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder set(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set2(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_set2, jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get0(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers build()
  /// The returned object must be released after use, by calling the [release] method.
  Headers build() {
    return const $HeadersType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Headers_BuilderType extends jni.JObjType<Headers_Builder> {
  const $Headers_BuilderType();

  @override
  String get signature => r"Lokhttp3/Headers$Builder;";

  @override
  Headers_Builder fromRef(jni.JObjectPtr ref) => Headers_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Headers_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_BuilderType) &&
        other is $Headers_BuilderType;
  }
}

/// from: okhttp3.Headers
class Headers extends jni.JObject {
  @override
  late final jni.JObjType<Headers> $type = type;

  Headers.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Headers");

  /// The type which includes information such as the signature of this class.
  static const type = $HeadersType();
  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get0(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_getDate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getDate", r"(Ljava/lang/String;)Ljava/util/Date;");

  /// from: public java.util.Date getDate(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDate(
    jni.JString string,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDate,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_getInstant = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getInstant",
      r"(Ljava/lang/String;)Ljava/time/Instant;");

  /// from: public java.time.Instant getInstant(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getInstant(
    jni.JString string,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getInstant,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_size =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"size", r"()I");

  /// from: public int size()
  int size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_size, jni.JniCallType.intType, []).integer;
  }

  static final _id_name = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"name", r"(I)Ljava/lang/String;");

  /// from: public java.lang.String name(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString name(
    int i,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_name,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_value = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"value", r"(I)Ljava/lang/String;");

  /// from: public java.lang.String value(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString value(
    int i,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_value,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_names = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"names", r"()Ljava/util/Set;");

  /// from: public java.util.Set names()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> names() {
    return const jni.JSetType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_names, jni.JniCallType.objectType, []).object);
  }

  static final _id_values = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"values", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List values(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> values(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_values, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_byteCount =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"byteCount", r"()J");

  /// from: public long byteCount()
  int byteCount() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_byteCount, jni.JniCallType.longType, []).long;
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder newBuilder() {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_toMultimap = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toMultimap", r"()Ljava/util/Map;");

  /// from: public java.util.Map toMultimap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> toMultimap() {
    return const jni.JMapType(
            jni.JStringType(), jni.JListType(jni.JStringType()))
        .fromRef(jni.Jni.accessors.callMethodWithArgs(
            reference, _id_toMultimap, jni.JniCallType.objectType, []).object);
  }

  static final _id_of = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"of", r"([Ljava/lang/String;)Lokhttp3/Headers;");

  /// from: static public okhttp3.Headers of(java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Headers of(
    jni.JArray<jni.JString> strings,
  ) {
    return const $HeadersType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of,
            jni.JniCallType.objectType, [strings.reference]).object);
  }

  static final _id_of1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"of", r"(Ljava/util/Map;)Lokhttp3/Headers;");

  /// from: static public okhttp3.Headers of(java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  static Headers of1(
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    return const $HeadersType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of1,
            jni.JniCallType.objectType, [map.reference]).object);
  }
}

final class $HeadersType extends jni.JObjType<Headers> {
  const $HeadersType();

  @override
  String get signature => r"Lokhttp3/Headers;";

  @override
  Headers fromRef(jni.JObjectPtr ref) => Headers.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HeadersType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HeadersType) && other is $HeadersType;
  }
}

/// from: okhttp3.Call$Factory
class Call_Factory extends jni.JObject {
  @override
  late final jni.JObjType<Call_Factory> $type = type;

  Call_Factory.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Call$Factory");

  /// The type which includes information such as the signature of this class.
  static const type = $Call_FactoryType();
  static final _id_newCall = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newCall", r"(Lokhttp3/Request;)Lokhttp3/Call;");

  /// from: public abstract okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return const $CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newCall,
        jni.JniCallType.objectType,
        [request.reference]).object);
  }
}

final class $Call_FactoryType extends jni.JObjType<Call_Factory> {
  const $Call_FactoryType();

  @override
  String get signature => r"Lokhttp3/Call$Factory;";

  @override
  Call_Factory fromRef(jni.JObjectPtr ref) => Call_Factory.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Call_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_FactoryType) &&
        other is $Call_FactoryType;
  }
}

/// from: okhttp3.Call
class Call extends jni.JObject {
  @override
  late final jni.JObjType<Call> $type = type;

  Call.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Call");

  /// The type which includes information such as the signature of this class.
  static const type = $CallType();
  static final _id_request = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"request", r"()Lokhttp3/Request;");

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.objectType, []).object);
  }

  static final _id_execute = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"execute", r"()Lokhttp3/Response;");

  /// from: public abstract okhttp3.Response execute()
  /// The returned object must be released after use, by calling the [release] method.
  Response execute() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_execute, jni.JniCallType.objectType, []).object);
  }

  static final _id_enqueue = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"enqueue", r"(Lokhttp3/Callback;)V");

  /// from: public abstract void enqueue(okhttp3.Callback callback)
  void enqueue(
    jni.JObject callback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_enqueue,
        jni.JniCallType.voidType, [callback.reference]).check();
  }

  static final _id_cancel =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"cancel", r"()V");

  /// from: public abstract void cancel()
  void cancel() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cancel, jni.JniCallType.voidType, []).check();
  }

  static final _id_isExecuted =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isExecuted", r"()Z");

  /// from: public abstract boolean isExecuted()
  bool isExecuted() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isExecuted, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isCanceled =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isCanceled", r"()Z");

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isCanceled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject timeout() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_clone = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clone", r"()Lokhttp3/Call;");

  /// from: public abstract okhttp3.Call clone()
  /// The returned object must be released after use, by calling the [release] method.
  Call clone() {
    return const $CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clone, jni.JniCallType.objectType, []).object);
  }
}

final class $CallType extends jni.JObjType<Call> {
  const $CallType();

  @override
  String get signature => r"Lokhttp3/Call;";

  @override
  Call fromRef(jni.JObjectPtr ref) => Call.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallType) && other is $CallType;
  }
}

/// from: okhttp3.ResponseBody
class ResponseBody extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody> $type = type;

  ResponseBody.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/ResponseBody");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBodyType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody() {
    return ResponseBody.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_contentType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contentType", r"()Lokhttp3/MediaType;");

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  MediaType contentType() {
    return const $MediaTypeType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentType, jni.JniCallType.objectType, []).object);
  }

  static final _id_contentLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contentLength", r"()J");

  /// from: public abstract long contentLength()
  int contentLength() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentLength, jni.JniCallType.longType, []).long;
  }

  static final _id_byteStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"byteStream", r"()Ljava/io/InputStream;");

  /// from: public final java.io.InputStream byteStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject byteStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_byteStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_source = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"source", r"()Lokio/BufferedSource;");

  /// from: public abstract okio.BufferedSource source()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSource source() {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_source, jni.JniCallType.objectType, []).object);
  }

  static final _id_bytes =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"bytes", r"()[B");

  /// from: public final byte[] bytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> bytes() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_bytes, jni.JniCallType.objectType, []).object);
  }

  static final _id_charStream = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"charStream", r"()Ljava/io/Reader;");

  /// from: public final java.io.Reader charStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_charStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_string = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"string", r"()Ljava/lang/String;");

  /// from: public final java.lang.String string()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_string, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create(
    MediaType mediaType,
    jni.JString string,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create,
            jni.JniCallType.objectType,
            [mediaType.reference, string.reference]).object);
  }

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create1(
    MediaType mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create1,
            jni.JniCallType.objectType,
            [mediaType.reference, bs.reference]).object);
  }

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create2(
    MediaType mediaType,
    jni.JObject byteString,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create2,
            jni.JniCallType.objectType,
            [mediaType.reference, byteString.reference]).object);
  }

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create3(
    MediaType mediaType,
    int j,
    BufferedSource bufferedSource,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create3,
            jni.JniCallType.objectType,
            [mediaType.reference, j, bufferedSource.reference]).object);
  }
}

final class $ResponseBodyType extends jni.JObjType<ResponseBody> {
  const $ResponseBodyType();

  @override
  String get signature => r"Lokhttp3/ResponseBody;";

  @override
  ResponseBody fromRef(jni.JObjectPtr ref) => ResponseBody.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBodyType) &&
        other is $ResponseBodyType;
  }
}

/// from: okhttp3.RequestBody
class RequestBody extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody> $type = type;

  RequestBody.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/RequestBody");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBodyType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody() {
    return RequestBody.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_contentType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contentType", r"()Lokhttp3/MediaType;");

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  MediaType contentType() {
    return const $MediaTypeType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentType, jni.JniCallType.objectType, []).object);
  }

  static final _id_contentLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contentLength", r"()J");

  /// from: public long contentLength()
  int contentLength() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentLength, jni.JniCallType.longType, []).long;
  }

  static final _id_writeTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeTo", r"(Lokio/BufferedSink;)V");

  /// from: public abstract void writeTo(okio.BufferedSink bufferedSink)
  void writeTo(
    jni.JObject bufferedSink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeTo,
        jni.JniCallType.voidType, [bufferedSink.reference]).check();
  }

  static final _id_isDuplex =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDuplex", r"()Z");

  /// from: public boolean isDuplex()
  bool isDuplex() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDuplex, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isOneShot =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isOneShot", r"()Z");

  /// from: public boolean isOneShot()
  bool isOneShot() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isOneShot, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create(
    MediaType mediaType,
    jni.JString string,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create,
            jni.JniCallType.objectType,
            [mediaType.reference, string.reference]).object);
  }

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create1(
    MediaType mediaType,
    jni.JObject byteString,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create1,
            jni.JniCallType.objectType,
            [mediaType.reference, byteString.reference]).object);
  }

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[B)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create2(
    MediaType mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create2,
            jni.JniCallType.objectType,
            [mediaType.reference, bs.reference]).object);
  }

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[BII)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create3(
    MediaType mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference, _id_create3, jni.JniCallType.objectType, [
      mediaType.reference,
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).object);
  }

  static final _id_create4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/io/File;)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create4(
    MediaType mediaType,
    jni.JObject file,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create4,
            jni.JniCallType.objectType,
            [mediaType.reference, file.reference]).object);
  }
}

final class $RequestBodyType extends jni.JObjType<RequestBody> {
  const $RequestBodyType();

  @override
  String get signature => r"Lokhttp3/RequestBody;";

  @override
  RequestBody fromRef(jni.JObjectPtr ref) => RequestBody.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBodyType) && other is $RequestBodyType;
  }
}

/// from: okhttp3.MediaType
class MediaType extends jni.JObject {
  @override
  late final jni.JObjType<MediaType> $type = type;

  MediaType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/MediaType");

  /// The type which includes information such as the signature of this class.
  static const type = $MediaTypeType();
  static final _id_get0 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Lokhttp3/MediaType;");

  /// from: static public okhttp3.MediaType get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static MediaType get0(
    jni.JString string,
  ) {
    return const $MediaTypeType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_get0,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_parse = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"parse", r"(Ljava/lang/String;)Lokhttp3/MediaType;");

  /// from: static public okhttp3.MediaType parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static MediaType parse(
    jni.JString string,
  ) {
    return const $MediaTypeType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_parse,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_type0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"type", r"()Ljava/lang/String;");

  /// from: public java.lang.String type()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString type0() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_type0, jni.JniCallType.objectType, []).object);
  }

  static final _id_subtype = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"subtype", r"()Ljava/lang/String;");

  /// from: public java.lang.String subtype()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString subtype() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_subtype, jni.JniCallType.objectType, []).object);
  }

  static final _id_charset = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"charset", r"()Ljava/nio/charset/Charset;");

  /// from: public java.nio.charset.Charset charset()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charset() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_charset, jni.JniCallType.objectType, []).object);
  }

  static final _id_charset1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"charset", r"(Ljava/nio/charset/Charset;)Ljava/nio/charset/Charset;");

  /// from: public java.nio.charset.Charset charset(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charset1(
    jni.JObject charset,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_charset1,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }
}

final class $MediaTypeType extends jni.JObjType<MediaType> {
  const $MediaTypeType();

  @override
  String get signature => r"Lokhttp3/MediaType;";

  @override
  MediaType fromRef(jni.JObjectPtr ref) => MediaType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaTypeType) && other is $MediaTypeType;
  }
}

/// from: okio.BufferedSource
class BufferedSource extends jni.JObject {
  @override
  late final jni.JObjType<BufferedSource> $type = type;

  BufferedSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/BufferedSource");

  /// The type which includes information such as the signature of this class.
  static const type = $BufferedSourceType();
  static final _id_buffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buffer", r"()Lokio/Buffer;");

  /// from: public abstract okio.Buffer buffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject buffer() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_getBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBuffer", r"()Lokio/Buffer;");

  /// from: public abstract okio.Buffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getBuffer() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBuffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_exhausted =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"exhausted", r"()Z");

  /// from: public abstract boolean exhausted()
  bool exhausted() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exhausted, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_require =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"require", r"(J)V");

  /// from: public abstract void require(long j)
  void require(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_require, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_request =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"request", r"(J)Z");

  /// from: public abstract boolean request(long j)
  bool request(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.booleanType, [j]).boolean;
  }

  static final _id_readByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readByte", r"()B");

  /// from: public abstract byte readByte()
  int readByte() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByte, jni.JniCallType.byteType, []).byte;
  }

  static final _id_readShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShort", r"()S");

  /// from: public abstract short readShort()
  int readShort() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShort, jni.JniCallType.shortType, []).short;
  }

  static final _id_readShortLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShortLe", r"()S");

  /// from: public abstract short readShortLe()
  int readShortLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShortLe, jni.JniCallType.shortType, []).short;
  }

  static final _id_readInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readInt", r"()I");

  /// from: public abstract int readInt()
  int readInt() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readInt, jni.JniCallType.intType, []).integer;
  }

  static final _id_readIntLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readIntLe", r"()I");

  /// from: public abstract int readIntLe()
  int readIntLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readIntLe, jni.JniCallType.intType, []).integer;
  }

  static final _id_readLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLong", r"()J");

  /// from: public abstract long readLong()
  int readLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readLongLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLongLe", r"()J");

  /// from: public abstract long readLongLe()
  int readLongLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLongLe, jni.JniCallType.longType, []).long;
  }

  static final _id_readDecimalLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readDecimalLong", r"()J");

  /// from: public abstract long readDecimalLong()
  int readDecimalLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readDecimalLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readHexadecimalUnsignedLong", r"()J");

  /// from: public abstract long readHexadecimalUnsignedLong()
  int readHexadecimalUnsignedLong() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_readHexadecimalUnsignedLong, jni.JniCallType.longType, []).long;
  }

  static final _id_skip =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"skip", r"(J)V");

  /// from: public abstract void skip(long j)
  void skip(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_skip, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_readByteString = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"()Lokio/ByteString;");

  /// from: public abstract okio.ByteString readByteString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject readByteString() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByteString, jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"(J)Lokio/ByteString;");

  /// from: public abstract okio.ByteString readByteString(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject readByteString1(
    int j,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readByteString1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_select = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"select", r"(Lokio/Options;)I");

  /// from: public abstract int select(okio.Options options)
  int select(
    jni.JObject options,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_select,
        jni.JniCallType.intType, [options.reference]).integer;
  }

  static final _id_readByteArray = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"()[B");

  /// from: public abstract byte[] readByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteArray1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"(J)[B");

  /// from: public abstract byte[] readByteArray(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray1(
    int j,
  ) {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_read =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([B)I");

  /// from: public abstract int read(byte[] bs)
  int read(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_read, jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_readFully =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readFully", r"([B)V");

  /// from: public abstract void readFully(byte[] bs)
  void readFully(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully,
        jni.JniCallType.voidType, [bs.reference]).check();
  }

  static final _id_read1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([BII)I");

  /// from: public abstract int read(byte[] bs, int i, int i1)
  int read1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read1,
        jni.JniCallType.intType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_readFully1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readFully", r"(Lokio/Buffer;J)V");

  /// from: public abstract void readFully(okio.Buffer buffer, long j)
  void readFully1(
    jni.JObject buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully1,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_readAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readAll", r"(Lokio/Sink;)J");

  /// from: public abstract long readAll(okio.Sink sink)
  int readAll(
    jni.JObject sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readAll,
        jni.JniCallType.longType, [sink.reference]).long;
  }

  static final _id_readUtf8 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"()Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf81 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"(J)Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf81(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf81, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_readUtf8Line = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8Line", r"()Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8Line()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8Line() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8Line, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"()Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8LineStrict()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"(J)Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8LineStrict(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict1(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_readUtf8CodePoint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8CodePoint", r"()I");

  /// from: public abstract int readUtf8CodePoint()
  int readUtf8CodePoint() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8CodePoint, jni.JniCallType.intType, []).integer;
  }

  static final _id_readString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(Ljava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public abstract java.lang.String readString(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString(
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_readString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(JLjava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public abstract java.lang.String readString(long j, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString1(
    int j,
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString1,
        jni.JniCallType.objectType,
        [j, charset.reference]).object);
  }

  static final _id_indexOf =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(B)J");

  /// from: public abstract long indexOf(byte b)
  int indexOf(
    int b,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf,
        jni.JniCallType.longType, [jni.JValueByte(b)]).long;
  }

  static final _id_indexOf1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJ)J");

  /// from: public abstract long indexOf(byte b, long j)
  int indexOf1(
    int b,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.longType, [jni.JValueByte(b), j]).long;
  }

  static final _id_indexOf2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJJ)J");

  /// from: public abstract long indexOf(byte b, long j, long j1)
  int indexOf2(
    int b,
    int j,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf2,
        jni.JniCallType.longType, [jni.JValueByte(b), j, j1]).long;
  }

  static final _id_indexOf3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;)J");

  /// from: public abstract long indexOf(okio.ByteString byteString)
  int indexOf3(
    jni.JObject byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf3,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOf4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;J)J");

  /// from: public abstract long indexOf(okio.ByteString byteString, long j)
  int indexOf4(
    jni.JObject byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf4,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_indexOfElement = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;)J");

  /// from: public abstract long indexOfElement(okio.ByteString byteString)
  int indexOfElement(
    jni.JObject byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOfElement1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;J)J");

  /// from: public abstract long indexOfElement(okio.ByteString byteString, long j)
  int indexOfElement1(
    jni.JObject byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement1,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_rangeEquals = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;)Z");

  /// from: public abstract boolean rangeEquals(long j, okio.ByteString byteString)
  bool rangeEquals(
    int j,
    jni.JObject byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_rangeEquals,
        jni.JniCallType.booleanType, [j, byteString.reference]).boolean;
  }

  static final _id_rangeEquals1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;II)Z");

  /// from: public abstract boolean rangeEquals(long j, okio.ByteString byteString, int i, int i1)
  bool rangeEquals1(
    int j,
    jni.JObject byteString,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_rangeEquals1,
        jni.JniCallType.booleanType,
        [j, byteString.reference, jni.JValueInt(i), jni.JValueInt(i1)]).boolean;
  }

  static final _id_peek = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"peek", r"()Lokio/BufferedSource;");

  /// from: public abstract okio.BufferedSource peek()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSource peek() {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_peek, jni.JniCallType.objectType, []).object);
  }

  static final _id_inputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"inputStream", r"()Ljava/io/InputStream;");

  /// from: public abstract java.io.InputStream inputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject inputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_inputStream, jni.JniCallType.objectType, []).object);
  }
}

final class $BufferedSourceType extends jni.JObjType<BufferedSource> {
  const $BufferedSourceType();

  @override
  String get signature => r"Lokio/BufferedSource;";

  @override
  BufferedSource fromRef(jni.JObjectPtr ref) => BufferedSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BufferedSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedSourceType) &&
        other is $BufferedSourceType;
  }
}
